---
phase: 07-idempotency-and-safety
plan: 02
type: execute
wave: 2
depends_on: [07-01]
files_modified: [install.sh]
autonomous: true

must_haves:
  truths:
    - "User sees progress feedback during installation"
    - "Verbose mode shows detailed sub-step output"
    - "Re-run with saved answers offers continue/edit/fresh options"
    - "Final summary shows installed/skipped/failed counts"
  artifacts:
    - path: "install.sh"
      provides: "Progress feedback and verbose output"
      contains: "show_status"
  key_links:
    - from: "run_step wrapper"
      to: "show_status"
      via: "progress messages"
      pattern: "show_status.*ok\\|skip"
    - from: "handle_saved_answers"
      to: "state.json questionnaire_answers"
      via: "load and save"
      pattern: "questionnaire_answers"
---

<objective>
Add progress feedback, verbose mode, saved answers, and installation summary

Purpose: The installer now skips completed steps (from Plan 01), but needs visual feedback about progress, a verbose mode for debugging, saved questionnaire answers for re-runs, and a final summary of what happened.

Output: Progress indicators, -v/--verbose flag, questionnaire answer persistence, final summary display
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-idempotency-and-safety/07-RESEARCH.md
@.planning/phases/07-idempotency-and-safety/07-CONTEXT.md
@.planning/phases/07-idempotency-and-safety/07-01-SUMMARY.md
@install.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add verbose flag and status display functions</name>
  <files>install.sh</files>
  <action>
Add verbose mode and status display infrastructure:

1. Add VERBOSE flag near other CLI flags (after SKIP_QUESTIONNAIRE):
```bash
VERBOSE=false
```

2. Add -v/--verbose to parse_args() (in the case statement):
```bash
-v|--verbose)
    VERBOSE=true
    ;;
```

3. Update show_help() to document verbose flag:
Add under Options section: "  -v, --verbose   Show detailed progress for each step"

4. Add verbose() helper function (in Input Functions section):
```bash
# Verbose output helper - only prints if VERBOSE is true
verbose() {
    if $VERBOSE; then
        echo "  $*"
    fi
}
```

5. Add show_status() function (after verbose):
```bash
# Show status message with color-coded indicator
# Args: status (ok|skip|fail|info), message
show_status() {
    local status="$1"
    local message="$2"

    case "$status" in
        ok|success)
            echo -e "${GREEN}[OK]${NC} $message"
            ;;
        skip|skipped)
            echo -e "${YELLOW}[SKIP]${NC} $message"
            ;;
        fail|failed)
            echo -e "${RED}[FAIL]${NC} $message"
            ;;
        info)
            echo -e "[INFO] $message"
            ;;
    esac
}
```

6. Update run_step() (from Plan 01) to use show_status:
- Change skip message from echo to: `show_status "skip" "$step_name (already completed)"`
- After successful step, add: `show_status "ok" "$step_name"`
- After failed step, add: `show_status "fail" "$step_name"`
  </action>
  <verify>Run ./install.sh --help and verify -v, --verbose appears in options</verify>
  <done>Verbose flag, verbose() helper, and show_status() function added</done>
</task>

<task type="auto">
  <name>Task 2: Add questionnaire answer persistence</name>
  <files>install.sh</files>
  <action>
Save questionnaire answers to state.json and reload on re-run:

1. Add save_questionnaire_answers() function (in State Tracking section):
```bash
# Save questionnaire answers to state.json for re-runs
save_questionnaire_answers() {
    local temp_file
    temp_file=$(mktemp)
    TEMP_FILES+=("$temp_file")

    # Build answers JSON (escape special characters in values)
    local name_escaped role_escaped areas_escaped prefs_escaped vault_escaped
    name_escaped=$(printf '%s' "${ANSWERS[name]:-}" | sed 's/"/\\"/g')
    role_escaped=$(printf '%s' "${ANSWERS[role]:-}" | sed 's/"/\\"/g')
    areas_escaped=$(printf '%s' "${ANSWERS[areas]:-}" | sed 's/"/\\"/g')
    prefs_escaped=$(printf '%s' "${ANSWERS[preferences]:-}" | sed 's/"/\\"/g')
    vault_escaped=$(printf '%s' "${ANSWERS[vault_path]:-}" | sed 's/"/\\"/g')

    # Check if questionnaire_answers already exists
    if grep -q '"questionnaire_answers"' "$MINERVIA_STATE_FILE" 2>/dev/null; then
        # Update existing - remove old block and add new
        awk '
            /"questionnaire_answers"/ { skip = 1 }
            skip && /^  \}/ { skip = 0; next }
            !skip { print }
        ' "$MINERVIA_STATE_FILE" > "$temp_file"
        # Add new answers before closing brace
        head -n -1 "$temp_file" > "${temp_file}.tmp"
        mv "${temp_file}.tmp" "$temp_file"
        cat >> "$temp_file" << ANSWERS_JSON
  "questionnaire_answers": {
    "name": "$name_escaped",
    "vault_path": "$vault_escaped",
    "role": "$role_escaped",
    "areas": "$areas_escaped",
    "preferences": "$prefs_escaped"
  }
}
ANSWERS_JSON
    else
        # Insert before closing brace
        head -n -1 "$MINERVIA_STATE_FILE" > "$temp_file"
        cat >> "$temp_file" << ANSWERS_JSON
  ,"questionnaire_answers": {
    "name": "$name_escaped",
    "vault_path": "$vault_escaped",
    "role": "$role_escaped",
    "areas": "$areas_escaped",
    "preferences": "$prefs_escaped"
  }
}
ANSWERS_JSON
    fi

    mv "$temp_file" "$MINERVIA_STATE_FILE"
}
```

2. Add has_saved_answers() function:
```bash
# Check if saved questionnaire answers exist
has_saved_answers() {
    [[ -f "$MINERVIA_STATE_FILE" ]] && \
    grep -q '"questionnaire_answers"' "$MINERVIA_STATE_FILE" 2>/dev/null
}
```

3. Add load_saved_answers() function:
```bash
# Load questionnaire answers from state.json into ANSWERS array
load_saved_answers() {
    if [[ ! -f "$MINERVIA_STATE_FILE" ]]; then
        return 1
    fi

    # Extract values using awk (handles quoted strings)
    ANSWERS[name]=$(awk -F'"' '/"name":/ {print $4}' "$MINERVIA_STATE_FILE" | head -1)
    ANSWERS[vault_path]=$(awk -F'"' '/"vault_path":/ {print $4}' "$MINERVIA_STATE_FILE" | head -1)
    ANSWERS[role]=$(awk -F'"' '/"role":/ {print $4}' "$MINERVIA_STATE_FILE" | head -1)
    ANSWERS[areas]=$(awk -F'"' '/"areas":/ {print $4}' "$MINERVIA_STATE_FILE" | head -1)
    ANSWERS[preferences]=$(awk -F'"' '/"preferences":/ {print $4}' "$MINERVIA_STATE_FILE" | head -1)
}
```

4. Add handle_saved_answers() function:
```bash
# Handle re-run with existing saved answers
# Returns: 0 if answers ready (loaded or fresh), 1 if should exit
handle_saved_answers() {
    if ! has_saved_answers; then
        return 1  # No saved answers, proceed with questionnaire
    fi

    load_saved_answers
    echo ""
    echo "Found saved configuration from previous install:"
    show_summary

    local action
    action=$(ask_choice "What would you like to do?" \
        "Use saved settings" \
        "Edit settings" \
        "Start fresh")

    case "$action" in
        "Use saved settings")
            return 0
            ;;
        "Edit settings")
            if ! confirm_summary; then
                run_questionnaire
            fi
            return 0
            ;;
        "Start fresh")
            run_questionnaire
            return 0
            ;;
    esac
}
```

5. Update the questionnaire section in main (around line 1445) to use saved answers:
Replace the existing questionnaire if/elif/else block with:
```bash
# Run questionnaire (interactive or skip if flags provided)
if [[ "${SKIP_QUESTIONNAIRE:-false}" == "true" ]]; then
    echo "Skipping questionnaire (--no-questionnaire)"
    # Validate required fields
    if [[ -z "${ANSWERS[name]:-}" ]] || [[ -z "${ANSWERS[vault_path]:-}" ]]; then
        error_exit "Non-interactive mode requires --name and --vault-path" \
            "Run with: ./install.sh --name \"Your Name\" --vault-path \"/path/to/vault\""
    fi
elif ! is_interactive; then
    echo "Non-interactive mode detected."
    if [[ -z "${ANSWERS[name]:-}" ]] || [[ -z "${ANSWERS[vault_path]:-}" ]]; then
        error_exit "Non-interactive mode requires --name and --vault-path" \
            "Run with: ./install.sh --name \"Your Name\" --vault-path \"/path/to/vault\""
    fi
elif handle_saved_answers; then
    : # Answers loaded from saved, continue
else
    run_questionnaire
fi
```

6. Call save_questionnaire_answers() after questionnaire is complete (before "Installing Minervia..." line):
```bash
# Save answers for future re-runs
save_questionnaire_answers
```

Note: The init_state_file must be called BEFORE handle_saved_answers can work. Move the state initialization earlier if needed (before questionnaire section).
  </action>
  <verify>Run installer twice in same vault. First run should prompt questionnaire. Second run should show saved answers with "Use saved settings" option.</verify>
  <done>Questionnaire answers persist across re-runs with edit option</done>
</task>

<task type="auto">
  <name>Task 3: Add final installation summary</name>
  <files>install.sh</files>
  <action>
Add a comprehensive final summary showing what happened during installation:

1. Add tracking variables at the top of Main Installation section:
```bash
# Installation counters
STEPS_INSTALLED=0
STEPS_SKIPPED=0
STEPS_FAILED=0
```

2. Update run_step() to increment counters:
- After successful step: `((STEPS_INSTALLED++)) || true`
- After skipped step: `((STEPS_SKIPPED++)) || true`
- After failed step: `((STEPS_FAILED++)) || true`

3. Add show_final_summary() function (after show_status):
```bash
# Display final installation summary
show_final_summary() {
    echo ""
    echo "======================================="
    echo "Installation Summary"
    echo "======================================="
    echo ""

    if $HAS_GUM; then
        gum style --border normal --padding "0 2" \
            "Steps completed: $STEPS_INSTALLED" \
            "Steps skipped:   $STEPS_SKIPPED" \
            "Steps failed:    $STEPS_FAILED"
    else
        echo -e "  ${GREEN}Completed:${NC} $STEPS_INSTALLED step(s)"
        echo -e "  ${YELLOW}Skipped:${NC}   $STEPS_SKIPPED step(s)"
        if [[ $STEPS_FAILED -gt 0 ]]; then
            echo -e "  ${RED}Failed:${NC}    $STEPS_FAILED step(s)"
        fi
    fi

    echo ""

    # Show what was installed
    if [[ $STEPS_INSTALLED -gt 0 ]] || [[ $STEPS_SKIPPED -gt 0 ]]; then
        echo "Skills installed to: $SKILLS_TARGET"
        echo "Agents installed to: $AGENTS_TARGET"
        echo ""
    fi

    # Show next steps only on first run
    if [[ "$FIRST_RUN" == "true" ]]; then
        echo "Next steps:"
        echo ""
        echo "1. Edit CLAUDE.md to match your vault structure"
        echo "2. Start Claude Code: claude"
        echo "3. Try: /log-to-daily after your first session"
        echo ""
        echo -e "${GREEN}Tip:${NC} Your first Claude session will show a welcome guide!"
        echo ""
    fi

    echo "Learn more at: https://github.com/aplaceforallmystuff/minervia-starter-kit"
    echo ""
}
```

4. Replace the existing final output section (lines ~1587-1606) with a call to show_final_summary():
Remove the hardcoded "Setup Complete!" section and replace with:
```bash
show_final_summary
```

Note: Keep the FIRST_RUN check logic but move it before the summary call so the variable is set correctly.
  </action>
  <verify>Run installer and verify final summary shows correct counts. Re-run and verify skipped count reflects steps that were already done.</verify>
  <done>Final summary displays installed/skipped/failed counts</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. Run `./install.sh --help` - verify -v, --verbose documented
2. Run `./install.sh -v` in test vault - verify verbose output appears
3. Re-run installer - verify saved answers prompt appears
4. Choose "Use saved settings" - verify installation continues with saved values
5. Check final summary shows correct counts
6. Run with --verbose to confirm detailed output
</verification>

<success_criteria>
- Progress feedback shows [OK], [SKIP], [FAIL] indicators
- --verbose flag produces detailed sub-step output
- Re-run with saved answers shows "Use saved settings / Edit / Start fresh" options
- Final summary accurately reflects installed, skipped, and failed counts
- Summary adapts based on first run vs re-run (next steps only on first run)
</success_criteria>

<output>
After completion, create `.planning/phases/07-idempotency-and-safety/07-02-SUMMARY.md`
</output>
