---
phase: 07-idempotency-and-safety
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [install.sh]
autonomous: true

must_haves:
  truths:
    - "Re-running installer skips previously completed steps"
    - "Step skip messages clearly indicate what was already done"
    - "Corrupted state file is detected and recovered"
    - "Concurrent installer runs are blocked"
  artifacts:
    - path: "install.sh"
      provides: "Step tracking infrastructure"
      contains: "is_step_complete"
  key_links:
    - from: "run_step wrapper"
      to: "state.json completed_steps"
      via: "is_step_complete/mark_step_complete"
      pattern: "completed_steps.*step"
---

<objective>
Add step-level completion tracking to enable safe installer re-runs

Purpose: The installer currently tracks individual files but not major steps (questionnaire, claudemd, scaffold, skills, agents). This plan adds step-level tracking so re-runs skip completed work without re-prompting.

Output: Functions for checking/marking step completion, state validation, lock file protection
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-idempotency-and-safety/07-RESEARCH.md
@.planning/phases/07-idempotency-and-safety/07-CONTEXT.md
@install.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add step completion tracking functions</name>
  <files>install.sh</files>
  <action>
Add step tracking infrastructure to install.sh in the State Tracking section (after record_installed_file):

1. Define step ID constants at the top of the State Tracking section:
```bash
# Step IDs for completion tracking
STEP_QUESTIONNAIRE="questionnaire"
STEP_CLAUDEMD="claudemd"
STEP_SCAFFOLD="scaffold"
STEP_SKILLS="skills"
STEP_AGENTS="agents"
```

2. Add is_step_complete() function:
- Takes step_id as argument
- Returns 0 if step found in completed_steps array, 1 otherwise
- Check state file exists first, return 1 if not
- Use grep to check for step in completed_steps (per RESEARCH.md pattern)

3. Add mark_step_complete() function:
- Takes step_id as argument
- Creates JSON entry: {"step": "$step_id", "completed_at": "$timestamp"}
- Uses ISO 8601 format for timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)
- Uses awk to insert entry into completed_steps array (follow pattern from record_installed_file)
- Handle both empty array case and existing entries case

4. Add run_step() wrapper function:
- Takes step_id, step_name (display), step_function (to call)
- If is_step_complete returns 0, print skip message and return 0
- Otherwise call the step_function
- If step_function returns 0, call mark_step_complete
- Return the step_function's exit code

Skip message format: "${GREEN}^${NC} $step_name (already completed)"

Note: Update init_state_file() to include empty completed_steps array in the initial JSON structure:
```json
{
  "version": "$VERSION",
  "installed_at": "...",
  "files": [],
  "completed_steps": []
}
```
  </action>
  <verify>Read install.sh and confirm is_step_complete, mark_step_complete, run_step functions exist with correct signatures</verify>
  <done>Step tracking functions added, init_state_file includes completed_steps array</done>
</task>

<task type="auto">
  <name>Task 2: Add state validation and lock file protection</name>
  <files>install.sh</files>
  <action>
Add safety mechanisms to prevent corruption and concurrent runs:

1. Add validate_state_file() function after init_state_file:
- Takes file path as argument
- Return 1 if file doesn't exist or is empty ([[ ! -s "$file" ]])
- Check for required fields with grep: "version", "files"
- Basic JSON validation: count { and } braces, should be equal
- Return 0 if valid, 1 if invalid

2. Add lock file handling:
- Define LOCK_FILE="$MINERVIA_STATE_DIR/.lock" constant with other state constants
- Add acquire_lock() function:
  - If lock file exists, read PID and check if process is running (kill -0 "$pid")
  - If running, error_exit with "Another installer is running (PID $pid)"
  - If stale lock (process not running), remove lock file
  - Write current PID ($$) to lock file
- Add release_lock() function:
  - Remove lock file if exists

3. Update cleanup trap to release lock:
- Change cleanup() to call release_lock before existing cleanup code
- The trap already exists, just modify the function

4. Add state validation at init_state_file call site (in Main Installation section):
- After init_state_file call, add validation check
- If validate_state_file returns non-zero, backup corrupted file and recreate:
```bash
if ! validate_state_file "$MINERVIA_STATE_FILE"; then
    echo -e "${YELLOW}!${NC} State file corrupted, recreating..."
    mv "$MINERVIA_STATE_FILE" "${MINERVIA_STATE_FILE}.corrupted-$(date +%Y%m%d)"
    init_state_file
fi
```

5. Add acquire_lock call early in main (after parse_args, before check_prerequisites)

Note: Lock file goes in MINERVIA_STATE_DIR, not VAULT_DIR, so it works across vaults.
  </action>
  <verify>Read install.sh and confirm validate_state_file, acquire_lock, release_lock exist. Check that cleanup calls release_lock.</verify>
  <done>State validation and lock protection added</done>
</task>

<task type="auto">
  <name>Task 3: Wire step tracking into main installation flow</name>
  <files>install.sh</files>
  <action>
Wrap major installation steps with run_step() for idempotent re-runs.

The main installation flow currently has these steps that need wrapping:
1. Questionnaire (run_questionnaire)
2. Vault scaffolding (scaffold_new_vault)
3. Skills installation (install_skills)
4. Agents installation (install_agents)
5. CLAUDE.md generation (process_template + handle)

For each step, replace the direct call with run_step wrapper:

1. **Questionnaire** (around line 1459):
Current: `run_questionnaire`
Change to: Create wrapper function `do_questionnaire()` that contains the questionnaire logic (the if/elif/else block), then call `run_step "$STEP_QUESTIONNAIRE" "Questionnaire" do_questionnaire`

Note: The questionnaire step is special because it sets ANSWERS. For re-runs where questionnaire is skipped, answers need to be loaded from state.json. This will be handled in Plan 02 (saved answers). For now, skip this step from wrapping to avoid complexity.

2. **Vault scaffolding** (around line 1487):
Current: `scaffold_new_vault`
Change to: `run_step "$STEP_SCAFFOLD" "Vault scaffolding" scaffold_new_vault`

3. **Skills installation** (around line 1509):
Current: `install_skills "$SKILLS_SOURCE" "$SKILLS_TARGET"`
Change to: Create wrapper `do_install_skills() { install_skills "$SKILLS_SOURCE" "$SKILLS_TARGET"; }`
Then: `run_step "$STEP_SKILLS" "Installing skills" do_install_skills`

4. **Agents installation** (around line 1513):
Current: `install_agents "$AGENTS_SOURCE" "$AGENTS_TARGET"`
Change to: Create wrapper `do_install_agents() { install_agents "$AGENTS_SOURCE" "$AGENTS_TARGET"; }`
Then: `run_step "$STEP_AGENTS" "Installing agents" do_install_agents`

5. **CLAUDE.md generation** (around line 1516-1539):
Current: Complex block with template processing and conflict handling
Change to: Create wrapper `do_generate_claudemd()` containing the entire block
Then: `run_step "$STEP_CLAUDEMD" "Generating CLAUDE.md" do_generate_claudemd`

Place wrapper functions right before the main installation section (after the Main Installation header comment).

Important: The vault detection (detect_vault_type) should NOT be wrapped - it needs to run every time to set IS_NEW_VAULT correctly for scaffold decision.
  </action>
  <verify>Run install.sh --help (should still work). Then do a test run in a test vault and verify skills/agents install. Re-run and verify skip messages appear.</verify>
  <done>Main installation steps wrapped with run_step for idempotent re-runs</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. Run `./install.sh --help` - should display help without errors
2. Create test vault, run installer, verify full installation completes
3. Check ~/.minervia/state.json has completed_steps array with entries
4. Re-run installer in same vault - should show skip messages for all steps
5. Check lock file created during run, removed after completion
</verification>

<success_criteria>
- Re-running installer shows "already completed" messages for previous steps
- state.json contains completed_steps array with step IDs and timestamps
- Corrupted state.json is detected and recovered with backup
- Concurrent installer runs blocked with clear error message
- Lock file cleaned up on normal exit and errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-idempotency-and-safety/07-01-SUMMARY.md`
</output>
