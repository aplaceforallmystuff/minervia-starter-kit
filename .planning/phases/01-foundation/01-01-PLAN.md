---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - install.sh
autonomous: true

must_haves:
  truths:
    - "Script exits immediately when any command fails"
    - "Unset variables cause script to exit with error"
    - "Pipe failures propagate correctly"
    - "Cleanup runs on both normal exit and error exit"
    - "Platform (macOS/Linux) is detected before any platform-specific operations"
    - "All error messages include actionable recovery steps"
  artifacts:
    - path: "install.sh"
      provides: "Foundation infrastructure for installer"
      contains: "set -euo pipefail"
  key_links:
    - from: "install.sh"
      to: "trap handler"
      via: "EXIT signal"
      pattern: "trap.*EXIT"
    - from: "install.sh"
      to: "platform detection"
      via: "uname check"
      pattern: "uname|PLATFORM"
---

<objective>
Add strict mode, trap handlers, platform detection, and error handling infrastructure to install.sh.

Purpose: Establish reliable foundation that prevents silent failures and handles macOS/Linux differences. All subsequent phases build on this error handling infrastructure.

Output: Refactored install.sh with strict mode, trap handlers, platform detection, and error messaging utilities.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-CONTEXT.md

@install.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add strict mode and trap handler infrastructure</name>
  <files>install.sh</files>
  <action>
Refactor install.sh to add foundational error handling:

1. Add strict mode after shebang:
   ```bash
   set -euo pipefail
   ```

2. Add trap handler for cleanup:
   ```bash
   cleanup() {
     local exit_code=$?
     # Cleanup logic here (remove temp files if any)
     exit $exit_code
   }
   trap cleanup EXIT
   ```

3. Add error handler function:
   ```bash
   error_exit() {
     local message="$1"
     local recovery="${2:-}"
     echo -e "${RED}ERROR:${NC} $message" >&2
     if [[ -n "$recovery" ]]; then
       echo -e "  ${YELLOW}Try:${NC} $recovery" >&2
     fi
     exit 1
   }
   ```

4. Move color definitions to top (after strict mode, before trap).

5. Wrap existing command checks to use error_exit with recovery steps:
   - Claude CLI missing: "Install from https://claude.ai/download"
   - Directory permissions: "Check write permissions or run from a different location"

Important: Do NOT change the functional behavior of the script. This task adds infrastructure only. Keep all existing functionality working.
  </action>
  <verify>
Run: `bash -n install.sh` (syntax check passes)
Run: `head -20 install.sh` (shows set -euo pipefail and trap)
  </verify>
  <done>
Script has strict mode enabled, trap handler for cleanup, and error_exit utility function. Syntax check passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add platform detection and compatibility layer</name>
  <files>install.sh</files>
  <action>
Add platform detection near the top of install.sh (after strict mode and color definitions):

1. Detect platform:
   ```bash
   detect_platform() {
     case "$(uname -s)" in
       Darwin)
         PLATFORM="macos"
         ;;
       Linux)
         PLATFORM="linux"
         ;;
       *)
         error_exit "Unsupported platform: $(uname -s)" "Minervia supports macOS and Linux only"
         ;;
     esac
   }
   detect_platform
   ```

2. Add compatibility wrapper for known BSD vs GNU differences:
   ```bash
   # Platform-specific command wrappers
   # Example: sed -i behaves differently on macOS vs Linux
   portable_sed_inplace() {
     if [[ "$PLATFORM" == "macos" ]]; then
       sed -i '' "$@"
     else
       sed -i "$@"
     fi
   }
   ```

3. Add PLATFORM variable export for use in later phases:
   ```bash
   export PLATFORM
   ```

Note: The current install.sh doesn't use sed -i or other platform-specific commands yet, but this infrastructure prepares for later phases. If you identify other BSD/GNU differences in the current script, add wrappers for those too.
  </action>
  <verify>
Run on macOS: `source install.sh 2>&1 | head -5` - should not error on platform detection
Run: `grep -n "PLATFORM" install.sh` - shows platform detection and export
  </verify>
  <done>
Platform is detected at script start. Unsupported platforms exit with clear error. Compatibility wrappers exist for known BSD/GNU differences.
  </done>
</task>

<task type="auto">
  <name>Task 3: Refactor existing error handling with actionable messages</name>
  <files>install.sh</files>
  <action>
Update all existing error cases to use consistent, actionable error messages:

1. Replace the Claude CLI check to use error_exit:
   ```bash
   if ! command -v claude &> /dev/null; then
     error_exit "Claude Code CLI not found" "Install from https://claude.ai/download"
   fi
   ```

2. Add explicit exit codes where missing. The script should use:
   - Exit 0: Success
   - Exit 1: General error / missing dependency
   - Exit 2: Invalid usage (for future --help handling)

3. Ensure all potential failure points have explicit error handling:
   - mkdir -p failures -> "Failed to create directory: $dir" / "Check write permissions"
   - cp -r failures -> "Failed to copy skill: $skill_name" / "Check disk space and permissions"

4. Add validation before operations that could fail silently:
   - Check SKILLS_SOURCE directory exists before iterating
   - Check target directory is writable before creating files

5. Review each echo/exit pair and ensure:
   - Message explains WHAT failed
   - Recovery step explains HOW to fix

Keep the friendly tone of the original script. Errors should be helpful, not scary.
  </action>
  <verify>
Manual review: Read through install.sh and confirm every error message has a recovery step.
Run: `grep -c "error_exit" install.sh` - should be 3+ uses
Run: `./install.sh` in a test directory - script should run successfully or fail with clear message
  </verify>
  <done>
All error cases use error_exit with actionable recovery steps. Exit codes are consistent (0 success, 1 error). Script maintains friendly tone while being helpful on failures.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Syntax validation:**
   ```bash
   bash -n install.sh
   ```

2. **Strict mode verification:**
   ```bash
   head -5 install.sh | grep -q "set -euo pipefail" && echo "PASS: strict mode"
   ```

3. **Platform detection verification:**
   ```bash
   grep -q "detect_platform" install.sh && echo "PASS: platform detection"
   ```

4. **Error handling verification:**
   ```bash
   grep -c "error_exit" install.sh  # Should be 3+
   ```

5. **Functional test:**
   ```bash
   # Create temp directory and test
   cd /tmp && mkdir -p minervia-test && cd minervia-test
   /path/to/install.sh  # Should complete or fail with clear message
   ```
</verification>

<success_criteria>
Phase 1 is complete when:

1. **CORE-03 satisfied:** Error messages are human-readable with actionable recovery steps
2. **CORE-07 satisfied:** Script exits with proper exit codes (0 success, non-zero failure)
3. **Strict mode active:** `set -euo pipefail` at script start
4. **Trap handler exists:** Cleanup function runs on exit
5. **Platform detected:** macOS vs Linux identified at startup
6. **No regressions:** Existing functionality still works
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
