---
phase: 08-update-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - minervia-update.sh
autonomous: true

must_haves:
  truths:
    - "User can run minervia-update.sh to check for updates"
    - "Script fetches latest version from GitHub without modifying vault"
    - "Script creates timestamped backup before any changes"
    - "User can run with --dry-run to preview changes"
  artifacts:
    - path: "minervia-update.sh"
      provides: "Update script core infrastructure"
      min_lines: 200
      exports: ["main", "fetch_latest", "create_backup", "get_installed_version"]
  key_links:
    - from: "minervia-update.sh"
      to: "~/.minervia/state.json"
      via: "version and checksum reading"
      pattern: "MINERVIA_STATE_FILE"
    - from: "minervia-update.sh"
      to: "GitHub repository"
      via: "git clone --depth 1"
      pattern: "git clone.*REPO_URL"
---

<objective>
Create the core minervia-update.sh script with git fetch, version comparison, backup creation, and dry-run infrastructure.

Purpose: Establish the foundational update mechanism that safely fetches new versions and creates backups before any modifications.

Output: Working minervia-update.sh script that can fetch latest version, compare with installed, create backups, and support --dry-run mode.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-update-system/08-CONTEXT.md
@.planning/phases/08-update-system/08-RESEARCH.md
@install.sh (reference for existing patterns: compute_md5, show_colored_diff, ask_choice, colors, cleanup trap)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create minervia-update.sh with core infrastructure</name>
  <files>minervia-update.sh</files>
  <action>
Create minervia-update.sh in the repository root (alongside install.sh) with:

**Header and setup:**
- Shebang: `#!/bin/bash`
- `set -euo pipefail`
- Header comment block matching install.sh style
- Color definitions (GREEN, YELLOW, RED, NC) matching install.sh
- REPO_URL constant: `https://github.com/aplaceforallmystuff/minervia-starter-kit.git`
- MINERVIA_STATE_DIR, MINERVIA_STATE_FILE, BACKUP_DIR constants
- TEMP_DIR variable initialized empty
- DRY_RUN and VERBOSE flags (default false)

**Argument parsing:**
- `--dry-run` sets DRY_RUN=true
- `-v, --verbose` sets VERBOSE=true
- `--list-backups` calls list_backups and exits
- `--restore TIMESTAMP` calls restore_backup and exits (stub for Plan 02)
- `-h, --help` shows usage
- Unknown options error with exit code 2

**Cleanup trap:**
- cleanup() function removes TEMP_DIR if set and non-empty
- Trap on EXIT, ERR, INT, TERM

**Helper functions (from install.sh patterns):**
- verbose() - prints only if VERBOSE is true
- compute_md5() - cross-platform MD5 (copy from install.sh)
- error_exit() - prints error with recovery hint, exits non-zero

**Core functions:**
- get_installed_version() - extracts version from state.json using grep/cut
- get_remote_version() - extracts VERSION from fetched install.sh
- fetch_latest() - git clone --depth 1 to TEMP_DIR, returns 1 on failure with friendly message
- is_newer_version() - compares two version strings (simple != check with sort -V for GNU, fallback to != for BSD)

**Stub functions (to be implemented in Plan 02):**
- scan_for_customizations() - echo "TODO" and return 0
- handle_customized_files() - echo "TODO" and return 0
- apply_updates() - echo "TODO" and return 0
- show_changelog_highlights() - echo "TODO" and return 0
- list_backups() - echo "No backups yet" and return 0
- restore_backup() - echo "Restore not implemented" and return 1

Make the script executable with chmod +x.
  </action>
  <verify>
Test script runs without errors:
```bash
./minervia-update.sh --help
./minervia-update.sh --dry-run  # Should fetch and show version comparison
```
  </verify>
  <done>Script exists, is executable, parses arguments, shows help, and --dry-run fetches version without modifying anything</done>
</task>

<task type="auto">
  <name>Task 2: Implement backup creation function</name>
  <files>minervia-update.sh</files>
  <action>
Add create_backup() function to minervia-update.sh:

**Function: create_backup()**
```bash
# Create timestamped backup of all tracked files
# Returns: backup path on success, exits on failure
create_backup() {
    local timestamp
    timestamp=$(date +%Y-%m-%dT%H-%M-%S)
    local backup_path="$BACKUP_DIR/$timestamp"

    # Create backup directory
    if ! mkdir -p "$backup_path"; then
        error_exit "Failed to create backup directory" "Check write permissions for $BACKUP_DIR"
    fi

    verbose "Backup directory: $backup_path"

    # Read files from state.json manifest
    if [[ ! -f "$MINERVIA_STATE_FILE" ]]; then
        echo "No state file found - nothing to backup"
        echo "$backup_path"
        return 0
    fi

    local backed_up=0

    # Parse files array from state.json
    while IFS= read -r rel_path; do
        [[ -z "$rel_path" ]] && continue

        local abs_path
        abs_path=$(resolve_path "$rel_path")

        [[ ! -f "$abs_path" ]] && continue

        # Create directory structure in backup
        local dest="$backup_path/$rel_path"
        mkdir -p "$(dirname "$dest")"

        if cp "$abs_path" "$dest" 2>/dev/null; then
            verbose "  Backed up: $rel_path"
            ((backed_up++))
        fi
    done < <(grep -o '"path": "[^"]*"' "$MINERVIA_STATE_FILE" | cut -d'"' -f4)

    echo "Backed up $backed_up files to $backup_path"
    echo "$backup_path"
}
```

**Function: resolve_path()**
```bash
# Resolve relative path to absolute path
# Args: relative_path (from state.json manifest)
# Returns: absolute path
resolve_path() {
    local rel_path="$1"

    if [[ "$rel_path" == skills/* ]] || [[ "$rel_path" == agents/* ]]; then
        echo "$HOME/.claude/$rel_path"
    else
        # Vault files - get vault path from state.json
        local vault_path
        vault_path=$(grep -o '"vault_path": "[^"]*"' "$MINERVIA_STATE_FILE" 2>/dev/null | cut -d'"' -f4 | head -1)
        if [[ -n "$vault_path" ]]; then
            echo "$vault_path/$rel_path"
        else
            # Fallback to current directory
            echo "$PWD/$rel_path"
        fi
    fi
}
```

Update main() to call create_backup() before any updates (stub for now, actual update call in Plan 02).
  </action>
  <verify>
Test backup creation:
```bash
# Run update which triggers backup
./minervia-update.sh --verbose
# Check backup was created
ls -la ~/.minervia/backups/
```
  </verify>
  <done>create_backup() creates timestamped backup directory with all tracked files, resolve_path() handles skills/agents/vault files</done>
</task>

<task type="auto">
  <name>Task 3: Implement main update flow skeleton</name>
  <files>minervia-update.sh</files>
  <action>
Implement main() function in minervia-update.sh:

```bash
main() {
    echo "Minervia Update"
    echo "==============="
    echo ""

    # Check state file exists
    if [[ ! -f "$MINERVIA_STATE_FILE" ]]; then
        error_exit "No Minervia installation found" "Run install.sh first"
    fi

    # Fetch latest version
    echo "Checking for updates..."
    if ! fetch_latest; then
        error_exit "Failed to fetch updates" "Check your internet connection"
    fi

    # Compare versions
    local installed_version remote_version
    installed_version=$(get_installed_version)
    remote_version=$(get_remote_version)

    echo ""
    echo "Installed: v$installed_version"
    echo "Latest:    v$remote_version"
    echo ""

    if [[ "$installed_version" == "$remote_version" ]]; then
        echo -e "${GREEN}Already up to date${NC}"
        return 0
    fi

    if ! is_newer_version "$installed_version" "$remote_version"; then
        echo -e "${YELLOW}Installed version is newer than remote${NC}"
        return 0
    fi

    echo -e "${GREEN}Update available: v$installed_version -> v$remote_version${NC}"
    echo ""

    # Show changelog highlights (stub)
    show_changelog_highlights "$installed_version" "$remote_version"

    # Dry run stops here
    if $DRY_RUN; then
        echo ""
        echo "[Dry run - no changes made]"
        echo ""
        # Preview what would be updated
        scan_for_customizations
        return 0
    fi

    # Scan for customizations
    echo ""
    echo "Scanning for customized files..."
    scan_for_customizations

    # Create backup
    echo ""
    echo "Creating backup..."
    local backup_path
    backup_path=$(create_backup)

    # Handle customized files (prompt for each - stub)
    handle_customized_files

    # Apply updates (stub)
    apply_updates

    # Update version in state.json
    # (Will be implemented in Plan 02)

    echo ""
    echo -e "${GREEN}Update complete${NC}"
    echo "Backup saved to: $backup_path"
}

# Run main
main
```

Ensure the script ties together all the infrastructure and can be run end-to-end (even though update application is stubbed).
  </action>
  <verify>
Test full flow:
```bash
# Dry run should work end-to-end
./minervia-update.sh --dry-run

# Verbose shows details
./minervia-update.sh --dry-run --verbose
```
  </verify>
  <done>main() orchestrates full update flow: fetch, compare versions, backup, stubs for customization handling and update application</done>
</task>

</tasks>

<verification>
After all tasks:
1. `./minervia-update.sh --help` shows usage
2. `./minervia-update.sh --dry-run` fetches, compares versions, shows what would happen
3. `./minervia-update.sh` creates backup in ~/.minervia/backups/
4. Script is executable and uses same patterns as install.sh
</verification>

<success_criteria>
- [ ] minervia-update.sh exists and is executable
- [ ] --help shows usage with all flags documented
- [ ] --dry-run fetches latest, compares versions, previews changes
- [ ] Backup creation works (timestamped directory with tracked files)
- [ ] Script handles missing state.json gracefully
- [ ] Network failure shows friendly error message
- [ ] Cleanup removes temp directory on exit
</success_criteria>

<output>
After completion, create `.planning/phases/08-update-system/08-01-SUMMARY.md`
</output>
